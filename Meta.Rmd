# (PART) Metaprogramming {-}

# Introduction {#meta}

```{r setup, include = FALSE}
source("common.R")
```

> "Flexibility in syntax, if it does not lead to ambiguity, would seem a
> reasonable thing to ask of an interactive programming language."
>
> --- Kent Pitman

R has powerful tools for computing not only on values, but also on the actions that lead to those values. If you're coming from another programming language, they are one of the most surprising features of R. Consider the following simple snippet of code that plots a sine curve:

```{r plot-labels, small_mar = TRUE, fig.width = 3.5, fig.height = 2.5}
x <- seq(0, 2 * pi, length = 100)
sinx <- sin(x)
plot(x, sinx, type = "l")
```

Look at the labels on the axes. How did R know that the variable on the x axis is called `x` and the variable on the y axis is called `sinx`? In most programming languages, you can only access the values of a function's arguments. In R, you can also access the code used to compute them. This makes it possible to evaluate code in non-standard ways: to use what is known as __non-standard evaluation__, or NSE for short. NSE is particularly useful for functions when doing interactive data analysis because it can dramatically reduce the amount of typing. \index{non-standard evaluation}

* Structure of code - symbols, calls, and pairlists.

* Quotation, including quasiquotation.

* Evaluation, the inverse of quotation.

Each chapter follows the same basic structure. Introduction and motivation. Then a discussion of the tidy evaluation approach. Then base R and other details. Finish with a case study.

If you just want to get a feel for tidy evaluation (including quasiquotation and quosure), you can just read the first two sections of each chapter, and skip the sections about base R and more advanced techniques. You might want to do that the first time you read through these chapters so you can get the big picture of how all the pieces fit together before going back for the details.

Finish with a chapter containing two case studies creating DSLs using the techniques from the previous chapters. One for generating latex, and one for generating HTML. Combine many of the ideas in this section.
