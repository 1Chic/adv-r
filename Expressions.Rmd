# Expressions

```{r setup, include = FALSE}
source("common.R")
library(rlang)
library(lobstr)
```

To compute on the language, we first need to understand its structure. That requires some new vocabulary, some new tools, and some new ways of thinking about R code. \index{expressions} The first thing you'll need to understand is the distinction between an operation and its result. Take this code, which takes a variable `x` multiplies it by 10 and saves the result to a new variable called `y`. It doesn't work because we haven't defined a variable called `x`:

```{r, error = TRUE}
y <- x * 10
```

It would be nice if we could capture the intent of the code, without executing the code. In other words, how can we separate our description of the action from performing it? One way is to use `rlang::expr()`: \indexc{expr()}

```{r}
z <- expr(y <- x * 10)
z
```

`expr()` returns a quoted __expression__: the R code that captures our intent.

In this chapter, you'll learn about the structure of those expressions, which will also help you understand how R executes code. Later, we'll learn about `eval()` which allows you to take such an expression and perform, or __evaluate__, it:

```{r}
x <- 4
eval(z)
y
```

## Abstract syntax trees

Quoted expressions are also called abstract syntax trees (AST) because the structure of code is fundamentally hierarchical and can be naturally represented as a tree. To make that more obvious we're going to introduce some graphical conventions, illustrated with the very simple call `f(x, "y", 1)`. \index{abstract syntax tree}

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/expression-simple.png", dpi = 450)
```
  
*   Function __calls__ define the hierarchy of the tree. Calls are shown
    with an orange square. The first child (`f`) is the function that gets 
    called. The second and subsequent children (`x`, `"y"`, and `1`) are the 
    arguments. 
  
    __NB__: Unlike many tree diagrams the order of the children is important: 
    `f(x, 1)` is not the same as `f(1, x)`.
    
*   The leaves of the tree are either __symbols__, like `f` and `x`, or 
    __constants__ like `1` or `"y"`. Symbols have a purple border and rounded 
    corners. Constants, which are atomic vectors of length one, have black 
    borders and square corners. Strings are always surrounded in quotes to
    emphasise their difference to symbols --- more on that later.

Drawing these diagrams by hand takes me some time, and obviously you can't rely on me to draw diagrams for your own code. I'll supplement the hand-drawn trees with trees drawn by `lobstr::ast()`. `ast()` tries to make trees as similar as possible to my hand-drawn trees, while respecting the limitations of the console. Let's use `ast()` to display the tree above:

```{r}
lobstr::ast(f(x, "y", 1))
```

Calls get an orange square, symbols are bold and purple, and strings are surrounded by quote marks. (The formatting is not currently shown in the rendered book, but you can see it if you run the code yourself.)

`ast()` supports "unquoting" with `!!` (pronounced bang-bang). We'll talk about unquoting in detail in the next chapter; for now note that it's useful if you've already used `expr()` to capture the expression.

```{r}
x <- expr(f(x, "y", 1))

# not useful!
lobstr::ast(x)

# what we want
lobstr::ast(!!x)
```

For more complex code, you can also use RStudio's tree viewer to explore the AST interactively, e.g. `View(expr(y <- x * 10))`.

### Infix vs. prefix calls

Every call in R can be written in tree form, even if it doesn't look like it at first glance. Take `y <- x * 10` again: what are the functions that are being called? It not as easy to spot as `f(x, 1)` because this expression contains two calls in __infix__ form: `<-` and `*`. Infix functions come **in**between their arguments (so an infix function can only have two arguments), whereas most functions in R are __prefix__ functions where the name of the function comes first [^1]. 

[^1]: Some programming languages use __postfix__ calls where the name of the function comes last. If you ever used an old HP calculator, you might have fallen in love with reverse Polish notation, postfix notation for algebra. There is also a family of "stack"-based programming languages descending from Forth which takes this idea as far as it might possibly go.

In R, any infix call can be converted to a prefix call if you you escape the function name with backticks. That means that these two lines of code are equivalent:

```{r, eval = FALSE}
y <- x * 10
`<-`(y, `*`(x, 10))
```

And they have this AST:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/expression-prefix.png", dpi = 450)
```

```{r}
lobstr::ast(y <- x * 10)
```

### Special forms

R has a small number of other syntactical constructs that don't look like either prefix or infix function calls. These are called __special forms__ and include `function`, the control flow operators (`if`, `for`, `while`, `repeat`), and parentheses (`{`, `(`, `[[`, and `[`). These can also be written in prefix form, and hence appear in the same way in the AST:

```{r}
lobstr::ast(function(x, y) {
  if (x > y) {
    x
  } else {
    y
  }
})
```

### Function factories

Another small detail we need to consider are calls like `f()()`. The first component of the call is usually a symbol:

```{r}
lobstr::ast(f(a, 1))
```

But if you are using a function factory, a function that returns another function, the first component might be anothre call:

```{r}
lobstr::ast(f()(a, 1))
```

(See [Function factories] for more details)

Of course that function might also take arguments:

```{r}
lobstr::ast(f(b, 2)())
```

These forms are relatively rare, but it's good to be able to recognise them when they crop up. 

### Argument names

So far the examples have only used unnamed arguments. Named arguments don't change the parsing rules, but just add some additional metadata:

```{r}
lobstr::ast(mean(x = mtcars$cyl, na.rm = TRUE))
```

(And note the appearance of another infix function: `$`)

### Exercises

1.  Which two of the six types of atomic vector can't appear in an expression? 
    Why? Why can't you create an expression that contains an atomic vector of 
    length greater than one? 

1.  Use `ast()` and experimentation to figure out the three arguments to an
    `if()` call. What would you call them? Which components are required? 
    
1.  What are the arguments to the `for()` and `while()` calls? 

1.  What does the call tree of an `if` statement with multiple `else if` 
    conditions look like? Why?
    
1.  Two arithmetic operators can be used in both prefix and infix style.
    What are they?

## R's grammar

The process by which a computer language takes sequence of tokens (like `x`, `+`, `y`) and constructs a tree is called __parsing__, and is governed by a set of rules known as a __grammar__. In this section, we'll use `lobstr::ast()` to explore some of the details of R's grammar. 

If this is your first reading the metaprogramming chapters, now is a good time to read the first sections of the next two chapters in order to get the big picture. Come back and learn more of the details once you've seen how all the big pieces fit together.

### Operator precedence and associativity

Infix functions introduce ambiguity in a way that prefix functions do not[^2]. The parser has to resolve two sources of ambiguity when parsing infix operators. First, what does `1 + 2 * 3` yield? Do you get 9 (i.e. `(1 + 2) * 3`), or 7 (i.e. `1 + (2 * 3)`).  Which of the two possible parse trees below does R use?

[^2] These two sources of ambiguity do not exist without infix operators, which can be considered an advantage of purely prefix and postfix languages. It's interesting to compare a simple arithmetic operation in Lisp (prefix) and Forth (postfix). In Lisp you'd write `(+ (+ 1 2) 3))`; this avoids ambiguity by requiring parentheses everywhere. In Forth, you'd write `1 2 + 3 +`; this doesn't require any parentheses, at the cost of requiring more thought when reading.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/expression-ambig-order.png", dpi = 450)
```

Programming langauges use conventions called __operator precedence__ to resolve this ambiguity using. We can `ast()` to see what R does: 

```{r}
lobstr::ast(1 + 2 * 3)
```

Predicting the precedence of arithmetic operations is usually easy because it's drilled into you in school and is consistent across the vast majority of programming languages. Predicting the precedence of other operators is harder. There's one particularly surprising finding in R: `!` has a much lower precedence (i.e. it binds less tightly) than you might expect. This allows you to write useful operations like:

```{r}
lobstr::ast(!x %in% y)
```

Another source of ambiguity is repeated usage of the same infix function. For example, is `1 + 2 + 3` equivalent to `(1 + 2) + 3` or to `1 + (2 + 3)`?  This normally doesn't matter because `x + y == y + x`,  i.e. addition is associative. However, some S3 classes define `+` in a non-associative way. For example, ggplot2 overloads `+` to build up a complex plot from simple pieces; this usage is non-associative because earlier layers are drawn underneath later layers.

In R, most operators are __left-associative__, i.e. the operations on the left are evaluated first:

```{r}
lobstr::ast(1 + 2 + 3)
```

R has over 30 infix operators divided into 18 precedence groups. While the details are descrbed in `?Syntax`, very few people have memorised the complete ordering. Indeed, if there's any confusion, use parentheses! 

These also appear in the AST, like all other special forms:

```{r}
lobstr::ast(1 + (2 + 3))
```

### Whitespace

R, in general, is not sensitive to white space. Most white space is not signficiant and is not recorded in the AST. `x+y` yields exactly the same AST as `x +        y`. This means that you're generally free to add whitespace to enhance the readability of your code. There's one major exception:

```{r}
lobstr::ast(y <- x)
lobstr::ast(y < -x)
```

### Parsing a string

Most of the time you type code into the console, and R takes care of turning the characters you've typed into an AST. But occasionally you have code stored in a string, and you want to parse it yourself. You can do so using `rlang::parse_expr()`:

```{r}
x1 <- "y <- x + 10"
lobstr::ast(!!x1)

x2 <- rlang::parse_expr(x1)
x2
lobstr::ast(!!x2)
```

(If you find yourself doing working with strings containing code very frequently, you should reconsider your work. Read the next chapter and consider if you can more safely generate with expressions using quasiquotation.)

The base equivalent to `parse_expr()` is `parse()`. It is a little harder to use because it's specialised for parsing R code stored in files. That means you need supply your string to the `text` argument, and you'll get back an expression object (more on that shortly) that you'll need to subset:

```{r}
parse(text = x1)[[1]]
```

### Deparsing

The opposite of parsing is __deparsing__: you have and AST and you want a string that would generate it:

```{r}
z <- expr(y <- x + 10)
expr_text(z)
```

Parsing and deparsing are not perfectly symmetrical because parsing throws away all information not directly related to the AST. This includes backticks around ordinary names, comments, and whitespace:

```{r}
cat(expr_text(expr({
  # This is a comment
  x <-             `x` + 1
})))
```

Deparsing is often used to provide default names for data structures (like data framse), and default labels for messages or other output. rlang provides two helpers for those situations:

```{r}
z <- expr(f(x, y, z))

expr_name(z)
expr_label(z)
```

Be careful when using the base R equivalent, `deparse()`: it returns a character vector, and with one element for each line. Whenever you use it, remember that the length of the output might be greater than one, and plan accordingly.

### Exercises

1.  R uses parentheses in two slightly different ways as illustrated by 
    this simple call: `f((1))`. Compare and contrast the two uses. 
    
1.  `=` can also be used in two ways. Construct a simple example that shows 
    both uses.

1.  What does `!1 + !1` return? Why?

1.  Which arithmetic operation is right associative?

1.  Why does `x1 <- x2 <- x3 <- 0` work? There are two reasons.

1.  Compare `x + y %+% z` to `x ^ y %+% z`. What does that tell you about 
    the precedence of custom infix functions?

1.  `deparse()` produces vectors when the input is long. For example, the 
    following call produces a vector of length two:

    ```{r, eval = FALSE}
    expr <- expr(g(a + b + c + d + e + f + g + h + i + j + k + l + m +
      n + o + p + q + r + s + t + u + v + w + x + y + z))
    
    deparse(expr)
    ```

    What do `expr_text()`, `expr_name()`, and `expr_label()` do?

## Data structures

Now that you have a good feel for ASTs and how R's grammar helps to define them, it's time to look into more detail about the underlying implementation. In this section you'll learn about the data structures that R uses to implement the AST:

* Constants and symbols
* Calls
* Pairlists

Before we continue, a word of caution about the naming conventions used in this book. Unfortunately, base R does not have a consistent set of conventions, so we've had to make some new one. We use them consistently in the book, but you'll need to learn some translations when reading R documentation.

We use expression to refer to the set of possible things that can be found in an AST. In base R, "expression" is a special type of object that is basically equivalent to a list. We call these __expression objects__, and will briefly discuss later. Base R does not have an equivalent term for our "expression". The closest is "language object", which includes symbols and calls, but not constants or pairlists. But note that `typeof()` and `str()` use "language" to mean call. Base R uses symbol and name interchangeably; we prefer symbol because "name" has other common meanings (e.g. the name of a variable).

### Constants and symbols

Constants and symbols are the leaves of the AST. Constants are "self-quoting", i.e. if the expression used to represent a constant is the constant itself:

```{r}
identical(expr("x"), "x")
identical(expr(TRUE), TRUE)
identical(expr(1), 1)
identical(expr(2), 2)
```

Symbols are used to represent variables. You can convert back and forth between symbols and the strings that represent them with `sym()` and `as_string()`:

```{r}
"x"
sym("x")
as_string(sym("x"))
```

There's one special symbol that needs a little extra discussion: the empty symbol, constructed with `expr()`. It's used to represent missing arguments so has some odd bevahiour. If you do, it triggers an error about missing arguments. It's primarily useful for programmatically creating a function with missing arguments. \index{names|empty}

```{r, error = TRUE}
x <- rlang::expr()
missing(x)

y <- x
```

### Calls

A call behaves similarly to a list. It has a `length()`; you can extract elements with  `[[`, `[`, and `$`; and calls can contain other calls. The main difference is that the first element of a call is special: it's the function that will get called. \index{calls} Let's explore these ideas with a simple example:

```{r}
x <- expr(read.table("important.csv", row = FALSE))
lobstr::ast(!!x)
```

The length of a call minus one gives the number of arguments:

```{r}
length(x) - 1
```

The names of a call are always empty for the first element and for unnamed arguments. 

```{r}
names(x)
```

You can extract the leaves of the call by position and by name using `[[` and `$` in the usual way:

```{r}
x[[1]]
x[[2]]

x$row
```

If you want to extract a specific argument from a function call, it's going to be challenge because it could potentially be in any location, with the full name, with an abreviated name, or with no name. To work around this problem, you can use `rlang::lang_standardise()` which standardises all arguments to use the full name: \indexc{standardise\_call()}

```{r}
rlang::lang_standardise(x)
```

(Note that if the function uses `...` it's not possible to standardise all arguments.)

You can also modify calls by combining the subsetting operators with `<-` in the usual way:

```{r}
x$header <- TRUE
x
```

You can use `[` to extract multiple components, but if you drop the the first element, you're usually going to end up with a weird call:

```{r}
x[2:3]
```

If you do want to extract multiple elements in this way, it's good practice to coerce the results to a list:

```{r}
as.list(x[2:3])
```

### Pairlists

The is one data structure we need to discuss for completeness: the pairlist. Pairlists are a holdover from R's past and have been replaced by lists everywhere except in function arguments. At the R-level behave identically to lists, but at the C-level they have different representation (linked lists rather than vector). \index{pairlists}

```{r}
f <- function(x = 10) x + 1
typeof(formals(f))
```

(At the C-level calls are actually implemented using pairlists)

Generally, whenever you encounter a pairlist, you can treat it just like a regular list.

```{r}
pl <- pairlist(x = 1, y = 2)
length(pl)
pl$x
```

The main difference is that because pairlists have a different underlying implementation, accessing their elements is much slower.

```{r}
l1 <- as.list(1:10)
l2 <- as.pairlist(l1)

microbenchmark::microbenchmark(
  l1[[1]],
  l1[[10]],
  l2[[1]],
  l2[[10]]
)
```

### Expression objects

Because there might be many top-level calls in a file, `parse()` doesn't return just a single expression. Instead, it returns an expression object, which is essentially a list of expressions: \index{expression object} 

```{r}
exp <- parse(text = c("
  x <- 4
  x
  5
"))
length(exp)
typeof(exp)
```

There is only one difference between expression objects and lists of language objects: `eval()` has special behaviour for expression objects. This is minor, and in the interest of using the fewest possible datatypes, I recommend avoid `expression()`. \indexc{expression()}

## Case study: Walking the AST with recursive functions {#ast-funs}

To conclude the chapter we're going to pull together everything that you've learned about ASTs to write solve more complicated tasks. Some inspiration comes from the base codetools package, which provides two interesting functions: \index{recursion!over ASTs}

* `findGlobals()` locates all global variables used by a function. This
  can be useful if you want to check that your function doesn't inadvertently
  rely on variables defined in their parent environment.

* `checkUsage()` checks for a range of common problems including
  unused local variables, unused parameters, and the use of partial
  argument matching.

These tools are somewhat similar to Lisp macros, as discussed in [Programmer's Niche: Macros in R](http://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf#page=10) by Thomas Lumley. However, macros are run at compile-time, which doesn't have any meaning in R, and always return expressions. They're also somewhat like Lisp [fexprs](http://en.wikipedia.org/wiki/Fexpr). A fexpr is a function where the arguments are not evaluated by default. The terms macro and fexpr are useful to know when looking for useful techniques from other languages. \index{macros} \index{fexprs}

To write functions like `findGlobals()` and `checkUsage()`, we need recursion, as recursive function are a natural pairing to tree data structures. There a two parts to the a recursive function:

* The recursive case: you re-call the function on a smaller sub-problem and
  then combine the results. For expressions, the recursive cases needs to 
  handle calls and pairlists.
  
* The base case: to ensure that function eventually terminates, you need to
  recognise when you have a problem that is easy to solve. For ASTs, this
  typically means that you've reached the leaves of the tree; the calls
  and names.

I recommend to start by implementing the base cases and then checking that you code works. with the base cases and then 

This means that a function for working with expressions will look like:

```{r, eval = FALSE}
recurse_call <- function(x) {
  if (is_constant(x)) {
    # Base case: return a value
  } else if (is_symbol(x)) {
    # Base case: return a value
  } else if (is_lang(x)) {
    # Recursive case
    lapply(x, recurse_call)
  } else if (is_pairlist(x)) {
    # Recursive case
    lapply(x, recurse_call)
  } else {
    # User supplied incorrect input
    stop("Don't know how to handle type ", typeof(x), 
      call. = FALSE)
  }
}
```

```{r}
expr_type <- function(x) {
  if (is_syntactic_literal(x)) {
    "constant"
  } else if (is.call(x)) {
    # since typeof returns language
    "call"
  } else {
    typeof(x)
  }
}

switch_expr <- function(x, ...) {
  switch(expr_type(x), 
    ..., 
    stop("Don't know how to handle type ", typeof(x), call. = FALSE)  
  )
}


```


### Finding F and T

We'll start simple with a function that determines whether a function uses the logical abbreviations `T` and `F`. Using `T` and `F` is generally considered to be poor coding practice, and is something that `R CMD check` will warn about. Let's first compare the AST for `T` vs. `TRUE`:

```{r}
ast(TRUE)
ast(T)
```

`TRUE` is parsed as a logical vector of length one, while `T` is parsed as a name. This tells us how to write our base cases for the recursive function: while an atomic vector will never be a logical abbreviation, a name might, so we'll need to test for both `T` and `F`. The recursive cases can be combined because they do the same thing in both cases: they recursively call `logical_abbr()` on each element of the object. \indexc{logical\_abbr}

```{r}
logical_abbr <- function(x) {
  switch_expr(x,
    # Base cases
    constant = FALSE,
    symbol = identical(x, expr(T)) || identical(x, expr(F)),
    
    # Recursive cases
    call = ,
    pairlist = {
      for (i in seq_along(x)) {
        if (logical_abbr(x[[i]])) return(TRUE)
      }
      FALSE
    }
  )
}


logical_abbr(expr(TRUE))
logical_abbr(expr(T))
logical_abbr(expr(mean(x, na.rm = T)))
logical_abbr(expr(function(x, na.rm = T) FALSE))
```

### Finding all variables created by assignment

`logical_abbr()` is very simple: it only returns a single `TRUE` or `FALSE`. The next task, listing all variables created by assignment, is a little more complicated. We'll start simply, and then make the function progressively more rigorous. \indexc{find\_assign()}

Again, we start by looking at the AST for assignment:

```{r}
ast(x <- 10)
```

Assignment is a call where the first element is the name `<-`, the second is the object the name is assigned to, and the third is the value to be assigned. This makes the base cases simple: constants and names don't create assignments, so they return `NULL`. The recursive cases aren't too hard either. We `lapply()` over pairlists and over calls to functions other than `<-`.

```{r}
find_assign <- function(x) {
  if (is.atomic(x) || is.name(x)) {
    NULL
  } else if (is.call(x)) {
    if (identical(x[[1]], expr(`<-`))) {
      x[[2]]
    } else {
      lapply(x, find_assign)
    }
  } else if (is.pairlist(x)) {
    lapply(x, find_assign)
  } else {
    stop("Don't know how to handle type ", typeof(x), 
      call. = FALSE)
  }
}
find_assign(expr(a <- 1))
find_assign(expr({
  a <- 1
  b <- 2
}))
```

This function works for these simple cases, but the output is rather verbose and includes some extraneous `NULL`s. Instead of returning a list, let's keep it simple and use a character vector. We'll also test it with two slightly more complicated examples:

```{r}
find_assign2 <- function(x) {
  if (is.atomic(x) || is.name(x)) {
    character()
  } else if (is.call(x)) {
    if (identical(x[[1]], expr(`<-`))) {
      as.character(x[[2]])
    } else {
      unlist(lapply(x, find_assign2))
    }
  } else if (is.pairlist(x)) {
    unlist(lapply(x, find_assign2))
  } else {
    stop("Don't know how to handle type ", typeof(x), 
      call. = FALSE)
  }
}

find_assign2(expr({
  a <- 1
  b <- 2
  a <- 3
}))

find_assign2(expr({
  system.time(x <- print(y <- 5))
}))
```

This is better, but we have two problems: dealing with repeated names and neglecting assignments inside other assignments. The fix for the first problem is easy. We need to wrap `unique()` around the recursive case to remove duplicate assignments. The fix for the second problem is a bit more tricky. We also need to recurse when the call is to `<-`. `find_assign3()` implements both strategies:

```{r}
find_assign3 <- function(x) {
  if (is.atomic(x) || is.name(x)) {
    character()
  } else if (is.call(x)) {
    if (identical(x[[1]], expr(`<-`))) {
      lhs <- as.character(x[[2]])
    } else {
      lhs <- character()
    }

    unique(c(lhs, unlist(lapply(x, find_assign3))))
  } else if (is.pairlist(x)) {
    unique(unlist(lapply(x, find_assign3)))
  } else {
    stop("Don't know how to handle type ", typeof(x), 
      call. = FALSE)
  }
}

find_assign3(expr({
  a <- 1
  b <- 2
  a <- 3
}))

find_assign3(expr({
  system.time(x <- print(y <- 5))
}))
```

We also need to test subassignment:

```{r}
find_assign3(expr({
  l <- list()
  l$a <- 5
  names(l) <- "b"
}))
```

We only want assignment of the object itself, not assignment that modifies a property of the object. Drawing the tree for the quoted object will help us see what condition to test for. The second element of the call to `<-` should be a name, not another call.

```{r}
ast(l$a <- 5)
ast(names(l) <- "b")
```

Now we have a complete version:

```{r}
find_assign4 <- function(x) {
  if (is.atomic(x) || is.name(x)) {
    character()
  } else if (is.call(x)) {
    if (identical(x[[1]], expr(`<-`)) && is.name(x[[2]])) {
      lhs <- as.character(x[[2]])
    } else {
      lhs <- character()
    }

    unique(c(lhs, unlist(lapply(x, find_assign4))))
  } else if (is.pairlist(x)) {
    unique(unlist(lapply(x, find_assign4)))
  } else {
    stop("Don't know how to handle type ", typeof(x), 
      call. = FALSE)
  }
}

find_assign4(expr({
  l <- list()
  l$a <- 5
  names(l) <- "b"
}))
```

While the complete version of this function is quite complicated, it's important to remember we wrote it by working our way up by writing simple component parts.

### Exercises

1.  Why does `logical_abbr()` use a for loop instead of a functional
    like `lapply()`?

1.  `logical_abbr()` works when given quoted objects, but doesn't work when
    given an existing function, as in the example below. Why not? How could
    you modify `logical_abbr()` to work with functions? Think about what
    components make up a function.

    ```{r, eval = FALSE}
    f <- function(x = TRUE) {
      g(x + T)
    }
    logical_abbr(f)
    ```

1.  Write a function called `ast_type()` that returns either "constant",
    "name", "call", or "pairlist". Rewrite `logical_abbr()`, `find_assign()`,
    and `bquote2()` to use this function with `switch()` instead of nested if
    statements.

1.  Write a function that extracts all calls to a function. Compare your
    function to `pryr::fun_calls()`.

1.  Improve the base `recurse_call()` template to also work with lists of
    functions and expressions (e.g., as from `parse(path_to_file))`.

## Exercises that need a home

1.  You can use `formals()` to both get and set the arguments of a function.
    Use `formals()` to modify the following function so that the default value
    of `x` is missing and `y` is 10.

    ```{r}
    g <- function(x = 20, y) {
      x + y
    }
    ```

1.  Write an equivalent to `get()` using `as.name()` and `eval()`. Write an
    equivalent to `assign()` using `as.name()`, `substitute()`, and `eval()`.
    (Don't worry about the multiple ways of choosing an environment; assume
    that the user supplies it explicitly.)

1.  Concatenating a call and an expression with `c()` creates a list. Implement
    `concat()` so that the following code works to combine a call and
    an additional argument.

    ```{r, eval = FALSE}
    c(quote(f()), list(a = 1, b = quote(mean(a)))
    concat(quote(f), a = 1, b = quote(mean(a)))
    #> f(a = 1, b = mean(a))
    ```
