# Conditions

```{r setup, include = FALSE}
source("common.R")
```

## Introduction

Not all problems are unexpected. When writing a function, you can often anticipate potential problems (like a non-existent file or the wrong type of input). Communicating these problems to the user is the job of __conditions__: errors, warnings, and messages.

* Fatal errors are raised by `stop()` and force all execution to terminate.
  Errors are used when there is no way for a function to continue. 

* Warnings are generated by `warning()` and are used to display potential
  problems, such as when some elements of a vectorised input are invalid,
  like `log(-1:2)`.

* Messages are generated by `message()` and are used to give informative output
  in a way that can easily be suppressed by the user (`?suppressMessages()`).
  I often use messages to let the user know what value the function has chosen
  for an important missing argument.

Conditions are usually displayed prominently, in a bold font or coloured red depending on your R interface. You can tell them apart because errors always start with "Error" and warnings with "Warning message". Function authors can also communicate with their users with `print()` or `cat()`, but I think that's a bad idea because it's hard to capture and selectively ignore this sort of output. Printed output is not a condition, so you can't use any of the useful condition handling tools you'll learn about below.

Condition handling tools, like `withCallingHandlers()`, `tryCatch()`, and `try()` allow you to take specific actions when a condition occurs. For example, if you're fitting many models, you might want to continue fitting the others even if one fails to converge. R offers an exceptionally powerful condition handling system based on ideas from Common Lisp, but it's currently not very well documented or often used. This chapter will introduce you to the most important basics, but if you want to learn more, I recommend the following two sources:

* [_A prototype of a condition system for R_](http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html) by Robert Gentleman and Luke Tierney. 
  This describes an early version of R's condition system. While the 
  implementation has changed somewhat since this document was written, it
  provides a good overview of how the pieces fit together, and some 
  motivation for its design.

* [_Beyond Exception Handling: Conditions and Restarts_](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html) 
  by Peter Seibel. This describes exception handling in Lisp, which happens 
  to be very similar to R's approach. It provides useful motivation and 
  more sophisticated examples. I have provided an R translation of the 
  chapter at <http://adv-r.had.co.nz/beyond-exception-handling.html>.

### Quiz {-}

Want to skip this chapter? Go for it, if you can answer the questions below. Find the answers at the end of the chapter in [answers](#conditions-answers).

1. What function do you use to ignore errors in block of code?

1. Why might you want to create an error with a custom S3 class?

## Signalling conditions

### Custom classes

One of the challenges of error handling in R is that most functions just call `stop()` with a string. That means if you want to figure out if a particular error occurred, you have to look at the text of the error message. This is error prone, not only because the text of the error might change over time, but also because many error messages are translated, so the message might be completely different to what you expect. \index{errors!custom classes}

R has a little known and little used feature to solve this problem. Conditions are S3 classes, so you can define your own classes if you want to distinguish different types of error. Each condition signalling function, `stop()`, `warning()`, and `message()`, can be given either a list of strings, or a custom S3 condition object. Custom condition objects are not used very often, but are very useful because they make it possible for the user to respond to different errors in different ways. For example, "expected" errors (like a model failing to converge for some input datasets) can be silently ignored, while unexpected errors (like no disk space available) can be propagated to the user.

R doesn't come with a built-in constructor function for conditions, but we can easily add one. Conditions must contain `message` and `call` components, and may contain other useful components. When creating a new condition, it should always inherit from `condition` and should in most cases inherit from one of `error`, `warning`, or `message`.

```{r}
condition <- function(subclass, message, call = sys.call(-1), ...) {
  structure(
    class = c(subclass, "condition"),
    list(message = message, call = call),
    ...
  )
}
is.condition <- function(x) inherits(x, "condition")
```

You can signal an arbitrary condition with `signalCondition()`, but nothing will happen unless you've instantiated a custom signal handler (with `tryCatch()` or `withCallingHandlers()`). Instead, pass this condition to `stop()`, `warning()`, or `message()` as appropriate to trigger the usual handling. R won't complain if the class of your condition doesn't match the function, but in real code you should pass a condition that inherits from the appropriate class: `"error"` for `stop()`,  `"warning"` for `warning()`, and  `"message"` for `message()`. \indexc{stop()}

```{r, eval = FALSE}
e <- condition(c("my_error", "error"), "This is an error")
signalCondition(e)
# NULL
stop(e)
# Error: This is an error
w <- condition(c("my_warning", "warning"), "This is a warning")
warning(w)
# Warning message: This is a warning
m <- condition(c("my_message", "message"), "This is a message")
message(m)
# This is a message
```

You can then use `tryCatch()` to take different actions for different types of errors. In this example we make a convenient `custom_stop()` function that allows us to signal error conditions with arbitrary classes. In a real application, it would be better to have individual S3 constructor functions that you could document, describing the error classes in more detail.

```{r}
custom_stop <- function(subclass, message, call = sys.call(-1), 
                        ...) {
  c <- condition(c(subclass, "error"), message, call = call, ...)
  stop(c)
}

my_log <- function(x) {
  if (!is.numeric(x))
    custom_stop("invalid_class", "my_log() needs numeric input")
  if (any(x < 0))
    custom_stop("invalid_value", "my_log() needs positive inputs")

  log(x)
}
tryCatch(
  my_log("a"),
  invalid_class = function(c) "class",
  invalid_value = function(c) "value"
)
```

Note that when using `tryCatch()` with multiple handlers and custom classes, the first handler to match any class in the signal's class hierarchy is called, not the best match. For this reason, you need to make sure to put the most specific handlers first:

```{r}
tryCatch(custom_stop("my_error", "!"),
  error = function(c) "error",
  my_error = function(c) "my_error"
)
tryCatch(custom_stop("my_error", "!"),
  my_error = function(c) "my_error",
  error = function(c) "error"
)
```



## Condition handling {#condition-handling}

Unexpected errors require interactive debugging to figure out what went wrong. Some errors, however, are expected, and you want to handle them automatically. In R, expected errors crop up most frequently when you're fitting many models to different datasets, such as bootstrap replicates. Sometimes the model might fail to fit and throw an error, but you don't want to stop everything. Instead, you want to fit as many models as possible and then perform diagnostics after the fact. \index{conditions}

In R, there are three tools for handling conditions (including errors) programmatically:

* `try()` gives you the ability to continue execution even when an error occurs.

* `tryCatch()` lets you specify __handler__ functions that control what
  happens when a condition is signalled.

* `withCallingHandlers()` is a variant of `tryCatch()` that establishes local
  handlers, whereas `tryCatch()` registers exiting handlers. Local handlers are
  called in the same context as where the condition is signalled, without
  interrupting the execution of the function. When an exiting handler from
  `tryCatch()` is called, the execution of the function is interrupted and the
  handler is called. `withCallingHandlers()` is rarely needed, but is useful to
  be aware of.

The following sections describe these tools in more detail.

## Ignore errors with try {#try}

`try()` allows execution to continue even after an error has occurred. For example, normally if you run a function that throws an error, it terminates immediately and doesn't return a value: \indexc{try()}

```{r, error = TRUE}
f1 <- function(x) {
  log(x)
  10
}
f1("x")
```

However, if you wrap the statement that creates the error in `try()`, the error message will be printed but execution will continue:

```{r, eval = FALSE}
f2 <- function(x) {
  try(log(x))
  10
}
f2("a")
#> Error in log(x) : non-numeric argument to mathematical function
#> [1] 10
```

You can suppress the message with `try(..., silent = TRUE)`.

To pass larger blocks of code to `try()`, wrap them in `{}`:

```{r}
try({
  a <- 1
  b <- "x"
  a + b
})
```

You can also capture the output of the `try()` function. If successful, it will be the last result evaluated in the block (just like a function). If unsuccessful it will be an (invisible) object of class "try-error":

```{r}
success <- try(1 + 2)
failure <- try("a" + "b")
class(success)
class(failure)
```

`try()` is particularly useful when you're applying a function to multiple elements in a list:

```{r, error = TRUE}
elements <- list(1:10, c(-1, 10), c(TRUE, FALSE), letters)
results <- lapply(elements, log)
results <- lapply(elements, function(x) try(log(x)))
```

There isn't a built-in function to test for the try-error class, so we'll define one. Then you can easily find the locations of errors with `sapply()` (as discussed in [Functionals](#functionals)), and extract the successes or look at the inputs that lead to failures.

```{r}
is.error <- function(x) inherits(x, "try-error")
succeeded <- !vapply(results, is.error, logical(1))

# look at successful results
str(results[succeeded])

# look at inputs that failed
str(elements[!succeeded])
```

Another useful `try()` idiom is using a default value if an expression fails. Simply assign the default value outside the try block, and then run the risky code:

```{r, eval = FALSE}
default <- NULL
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)
```

There is also `plyr::failwith()`, which makes this strategy even easier to implement. See [Function Operators](#output-fos) for more details.

### Interrupts

## Handle conditions with `tryCatch()`

`tryCatch()` is a general tool for handling conditions: in addition to errors, you can take different actions for warnings, messages, and interrupts.  You've seen errors (made by `stop()`), warnings (`warning()`) and messages (`message()`) before, but interrupts are new. They can't be generated directly by the programmer, but are raised when the user attempts to terminate execution by pressing Ctrl + Break, Escape, or Ctrl + C (depending on the platform). \indexc{tryCatch()} \index{errors!catching}

With `tryCatch()` you map conditions to __handlers__, named functions that are called with the condition as an input. If a condition is signalled, `tryCatch()` will call the first handler whose name matches one of the classes of the condition. The only useful built-in names are `error`, `warning`, `message`, `interrupt`, and the catch-all `condition`. A handler function can do anything, but typically it will either return a value or create a more informative error message. For example, the `show_condition()` function below sets up handlers that return the type of condition signalled: \index{error handlers}

```{r}
show_condition <- function(code) {
  tryCatch(code,
    error = function(c) "error",
    warning = function(c) "warning",
    message = function(c) "message"
  )
}
show_condition(stop("!"))
show_condition(warning("?!"))
show_condition(message("?"))

# If no condition is captured, tryCatch returns the 
# value of the input
show_condition(10)
```

You can use `tryCatch()` to implement `try()`. A simple implementation is shown below. `base::try()` is more complicated in order to make the error message look more like what you'd see if `tryCatch()` wasn't used. Note the use of `conditionMessage()` to extract the message associated with the original error.

```{r}
try2 <- function(code, silent = FALSE) {
  tryCatch(code, error = function(c) {
    msg <- conditionMessage(c)
    if (!silent) message(c)
    invisible(structure(msg, class = "try-error"))
  })
}

try2(1)
try2(stop("Hi"))
try2(stop("Hi"), silent = TRUE)
```

As well as returning default values when a condition is signalled, handlers can be used to make more informative error messages. For example, by modifying the message stored in the error condition object, the following function wraps `read.csv()` to add the file name to any errors:

```{r, error = TRUE, warning = FALSE}
read.csv2 <- function(file, ...) {
  tryCatch(read.csv(file, ...), error = function(c) {
    c$message <- paste0(c$message, " (in ", file, ")")
    stop(c)
  })
}
read.csv("code/dummy.csv")
read.csv2("code/dummy.csv")
```

Catching interrupts can be useful if you want to take special action when the user tries to abort running code. But be careful, it's easy to create a loop that you can never escape (unless you kill R)! \index{interrupts}

```{r, eval = FALSE}
# Don't let the user interrupt the code
i <- 1
while(i < 3) {
  tryCatch({
    Sys.sleep(0.5)
    message("Try to escape")
  }, interrupt = function(x) {
    message("Try again!")
    i <<- i + 1
  })
}
```

`tryCatch()` has one other argument: `finally`. It specifies a block of code (not a function) to run regardless of whether the initial expression succeeds or fails. This can be useful for clean up (e.g., deleting files, closing connections). This is functionally equivalent to using `on.exit()` but it can wrap smaller chunks of code than an entire function. \indexc{on.exit()}

## `withCallingHandlers()`

An alternative to `tryCatch()` is `withCallingHandlers()`. The difference between the two is that the former establishes *exiting* handlers while the latter registers *local* handlers. Here are the main differences between the two kind of handlers: \indexc{withCallingHandlers()}

* The handlers in `withCallingHandlers()` are called in the context of the
  call that generated the condition whereas the handlers in `tryCatch()` are
  called in the context of `tryCatch()`. This is shown here with `sys.calls()`,
  which is the run-time equivalent of `traceback()` --- it lists all calls
  leading to the current function.

    ```{r, eval = FALSE}
    f <- function() g()
    g <- function() h()
    h <- function() stop("!")

    tryCatch(f(), error = function(e) print(sys.calls()))
    # [[1]] tryCatch(f(), error = function(e) print(sys.calls()))
    # [[2]] tryCatchList(expr, classes, parentenv, handlers)
    # [[3]] tryCatchOne(expr, names, parentenv, handlers[[1L]])
    # [[4]] value[[3L]](cond)

    withCallingHandlers(f(), error = function(e) print(sys.calls()))
    # [[1]] withCallingHandlers(f(), 
    #    error = function(e) print(sys.calls()))
    # [[2]] f()
    # [[3]] g()
    # [[4]] h()
    # [[5]] stop("!")
    # [[6]] .handleSimpleError(
    #    function (e) print(sys.calls()), "!", quote(h()))
    # [[7]] h(simpleError(msg, call))
    ```

    This also affects the order in which `on.exit()` is called.

* A related difference is that with `tryCatch()`, the flow of execution is
  interrupted when a handler is called, while with `withCallingHandlers()`,
  execution continues normally when the handler returns. This includes the
  signalling function which continues its course after having called the handler
  (e.g., `stop()` will continue stopping the program and `message()` or
  `warning()` will continue signalling a message/warning). This is why it is
  often better to handle a message with `withCallingHandlers()` rather than
  `tryCatch()`, since the latter will stop the program:

    ```{r, message = TRUE}
    message_handler <- function(c) cat("Caught a message!\n")

    tryCatch(message = message_handler, {
      message("Someone there?")
      message("Why, yes!")
    })

    withCallingHandlers(message = message_handler, {
      message("Someone there?")
      message("Why, yes!")
    })
    ```

* The return value of a handler is returned by `tryCatch()`, whereas it is
  ignored with `withCallingHandlers()`:

    ```{r, message = TRUE}
    f <- function() message("!")
    tryCatch(f(), message = function(m) 1)
    withCallingHandlers(f(), message = function(m) 1)
    ```

These subtle differences are rarely useful, except when you're trying to capture exactly what went wrong and pass it on to another function. For most purposes, you should never need to use `withCallingHandlers()`.

### Exercises

* Compare the following two implementations of `message2error()`. What is the
  main advantage of `withCallingHandlers()` in this scenario? (Hint: look
  carefully at the traceback.)

    ```{r}
    message2error <- function(code) {
      withCallingHandlers(code, message = function(e) stop(e))
    }
    message2error <- function(code) {
      tryCatch(code, message = function(e) stop(e))
    }
    ```



## Quiz answers {#conditions-answers}

1. You could use `try()` or `tryCatch()`.

1. Because you can then capture specific types of error with `tryCatch()`,
   rather than relying on the comparison of error strings, which is risky,
   especially when messages are translated.
