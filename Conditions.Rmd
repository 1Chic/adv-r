# Conditions

```{r, include = FALSE}
source("common.R")
```

## Introduction

Not all problems are unexpected. When writing a function, you can often anticipate potential problems (like a non-existent file or the wrong type of input). Communicating these problems to the user is the job of __conditions__ such as errors, warnings, and messages.

Conditions are usually displayed prominently, in a bold font or coloured red depending on your R interface. You can tell them apart because errors always start with "Error" and warnings with "Warning message". Function authors can also communicate with their users with `print()` or `cat()`, but I think that's a bad idea because it's hard to capture and selectively ignore this sort of output. Printed output is not a condition, so you can't use any of the useful condition handling tools you'll learn about below.

Condition handling tools, like `withCallingHandlers()`, `tryCatch()`, and `try()` allow you to take specific actions when a condition occurs. For example, if you're fitting many models, you might want to continue fitting the others even if one fails to converge. R offers an exceptionally powerful condition handling system based on ideas from Common Lisp, but it's currently not very well documented or often used. This chapter will introduce you to the most important basics, but if you want to learn more, I recommend the following two sources:

* [_A prototype of a condition system for R_](http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html) by Robert Gentleman and Luke Tierney. 
  This describes an early version of R's condition system. While the 
  implementation has changed somewhat since this document was written, it
  provides a good overview of how the pieces fit together, and some 
  motivation for its design.

* [_Beyond Exception Handling: Conditions and Restarts_](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html) 
  by Peter Seibel. This describes exception handling in Lisp, which happens 
  to be very similar to R's approach. It provides useful motivation and 
  more sophisticated examples. I have provided an R translation of the 
  chapter at <http://adv-r.had.co.nz/beyond-exception-handling.html>.

### Quiz {-}

Want to skip this chapter? Go for it, if you can answer the questions below. Find the answers at the end of the chapter in [answers](#conditions-answers).

1. What function do you use to ignore errors in block of code?

1. Why might you want to create an error with a custom S3 class?

### Prerequisites

```{r setup}
library(rlang)
```

## Introduction

There are four conditions used widely through out R: errors, warnings, messages, and interrupts. To understand what's going on, we need a function that allows us to capture and inspect condition objects:

```{r}
capture_condition <- function(code) {
  tryCatch(
    {
      code
      NULL
    },
    condition = function(e) {
      e
    }
  )
}
```

Don't worry if you haven't seen `tryCatch()` before; you'll learn more about it later.

### Errors

Fatal errors are raised by `stop()` and force all execution to terminate. Errors are used when there is no way for a function to continue. 

```{r, error = TRUE}
stop("This is an error message")
```

To learn more about the internal construction of the object, we need to capture it:

```{r}
e <- capture_condition(stop("Oops"))
str(e)
```

This shows us that the error object has class inherits from "condition". And it has two components: the error message, and the call from which the error occured.

The call is often not useful, so I think it's good practice to use `call. = FALSE`

```{r, error = TRUE}
stop("No call info", call. = FALSE)

e <- capture_condition(stop("Oops", call. = FALSE))
str(e)
```

Something about rlang errors and capturing the traceback (when that actually works).

### Warnings

Warnings are weaker than errors: they signal that something has gone wrong, but the code has been able to recover and continue. They are generated by `warning()`.

```{r}
f <- function() {
  cat("1\n")
  warning("W1")
  cat("2\n")
  warning("W2")
  cat("3\n")
  warning("W3")
}
```

By defaults, warnings are cached and printed only when control returns to the top level. 

```{r, eval = FALSE}
f()
#> 1
#> 2
#> 3
#> Warning messages:
#> 1: In f() : W1
#> 2: In f() : W2
#> 3: In f() : W3
```

You can override this setting in two ways:

* To control someone elses warnings, set `options(warn = 1)`
* To control your own warnings, set `immediate. = TRUE`

Warning objects are very similar to errro objects. They have `message` and `call`, and are inherit from the condition class.

```{r}
e <- capture_condition(warning("Oops"))
str(e)
```

You should be cautious with your use of `warnings()`: warnings are easy to miss if there's a lot of other output, and you don't want your function to recover too easily from clearly incorrect input. Reserve warnings for when you're almost sure that the result is correct, but there's something the user really should know. A good use of warnings is for deprecation: the code works, but will not work in the future, or generally a better method is available. 

Base R tends to use warnings when only part of a vectorised input is invalid. However, I don't find these warnings terrifically informative: they don't tell you where the problem lies in the vector, and when embedded inside other code, it is challenging to figure the source of the warning. In fact, usually the best technique is to turn warnings into errors with `options(warn = 2)`. Then you can use your existing error diagnosis skills.

```{r}
log(c(-1, 10, 100))

as.numeric(c("a", "1", "10"))
```

### Messages

Messages are generated by `message()` and are used to give informative output in a way that can easily be suppressed by the user (`?suppressMessages()`). I often use messages to let the user know what value the function has chosen for an important missing argument.

Messages are also important when developing packages. you need to print messages during startup, use ``packageStartupMessage()`: that ensures `library(yourpackage, quietly = TRUE)` hides all your messages too.

Generally, you should use `message()` rather than `cat()` or `print()` for informing the user about actions that your function has taken. This is useful, for example, if you've had to do non-trivial computation to determine the default value of an argument, and you want to let the user know exactly what you've done.

### Interrupts
  
Interrupts can't be generated directly by the programmer, but are raised when the user attempts to terminate execution by pressing Ctrl + Break, Escape,  or Ctrl + C (depending on the platform). 

## Condition handling {#condition-handling}

Unexpected errors require interactive debugging to figure out what went wrong. Some errors, however, are expected, and you want to handle them automatically. In R, expected errors crop up most frequently when you're fitting many models to different datasets, such as bootstrap replicates. Sometimes the model might fail to fit and throw an error, but you don't want to stop everything. Instead, you want to fit as many models as possible and then perform diagnostics after the fact. \index{conditions}

In R, there are three tools for handling conditions (including errors) programmatically:

* `try()` gives you the ability to continue execution even when an error occurs.

* `tryCatch()` lets you specify __handler__ functions that control what
  happens when a condition is signalled.

* `withCallingHandlers()` is a variant of `tryCatch()` that establishes local
  handlers, whereas `tryCatch()` registers exiting handlers. Local handlers are
  called in the same context as where the condition is signalled, without
  interrupting the execution of the function. When an exiting handler from
  `tryCatch()` is called, the execution of the function is interrupted and the
  handler is called. `withCallingHandlers()` is rarely needed, but is useful to
  be aware of.

The following sections describe these tools in more detail.

## Muffling conditions 

### Ignoring errors

`try()` allows execution to continue even after an error has occurred. For example, normally if you run a function that throws an error, it terminates immediately and doesn't return a value: \indexc{try()}

```{r, error = TRUE}
f1 <- function(x) {
  log(x)
  10
}
f1("x")
```

However, if you wrap the statement that creates the error in `try()`, the error message will be printed but execution will continue:

```{r, eval = FALSE}
f2 <- function(x) {
  try(log(x))
  10
}
f2("a")
#> Error in log(x) : non-numeric argument to mathematical function
#> [1] 10
```

You can suppress the message with `try(..., silent = TRUE)`.

To pass larger blocks of code to `try()`, wrap them in `{}`:

```{r}
try({
  a <- 1
  b <- "x"
  a + b
})
```

You can also capture the output of the `try()` function. If successful, it will be the last result evaluated in the block (just like a function). If unsuccessful it will be an (invisible) object of class "try-error":

```{r}
success <- try(1 + 2)
failure <- try("a" + "b")
class(success)
class(failure)
```

`try()` is particularly useful when you're applying a function to multiple elements in a list:

```{r, error = TRUE}
elements <- list(1:10, c(-1, 10), c(TRUE, FALSE), letters)
results <- lapply(elements, log)
results <- lapply(elements, function(x) try(log(x)))
```

There isn't a built-in function to test for the try-error class, so we'll define one. Then you can easily find the locations of errors with `sapply()` (as discussed in [Functionals](#functionals)), and extract the successes or look at the inputs that lead to failures.

```{r}
is.error <- function(x) inherits(x, "try-error")
succeeded <- !vapply(results, is.error, logical(1))

# look at successful results
str(results[succeeded])

# look at inputs that failed
str(elements[!succeeded])
```

Another useful `try()` idiom is using a default value if an expression fails. Simply assign the default value outside the try block, and then run the risky code:

```{r, eval = FALSE}
default <- NULL
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)
```

### Silencing messages and warnings

`suppressWarnings()`; 
`suppressMessages()`.

The implementation of these functions are complex because they rely on the restart system. This is basically the only use of the restart system in base R (or pretty much any package) so we don't discuss here.

## Handling conditions
\index{errors!catching}
\index{signals!handling}

### `tryCatch()`
\indexc{tryCatch()} 

`tryCatch()` is a general tool for handling conditions. It allows you to map map conditions to __handlers__, functions that are called with the condition as an input. If a condition is signalled, `tryCatch()` will call the first handler whose name matches one of the classes of the condition. The names useful for built-in conditions are `error`, `warning`, `message`, `interrupt`, and the catch-all `condition`.

A handler function can do anything, but typically it will either return a value or create a more informative error message. For example, the `show_condition()` function below sets up handlers that return the type of condition signalled: \index{error handlers}

```{r}
show_condition <- function(code) {
  tryCatch(
    {
      code
      NULL
    },
    error = function(c) "error",
    warning = function(c) "warning",
    message = function(c) "message"
  )
}
show_condition(stop("!"))
show_condition(warning("?!"))
show_condition(message("?"))

# If no condition is captured, tryCatch returns NULL
show_condition(10)
```

You can use `tryCatch()` to implement `try()`. A simple implementation is shown below. `base::try()` is more complicated in order to make the error message look more like what you'd see if `tryCatch()` wasn't used. Note the use of `conditionMessage()` to extract the message associated with the original error.

```{r}
try2 <- function(code, silent = FALSE) {
  tryCatch(code, error = function(c) {
    msg <- conditionMessage(c)
    if (!silent) message(msg)
    structure(msg, class = "try-error")
  })
}

try2(1)

try2(stop("Hi"))

try2(stop("Hi"), silent = TRUE)
```

### Re-signalling conditions

As well as returning default values when a condition is signalled, handlers can be used to make more informative error messages. For example, by modifying the message stored in the error condition object, the following function wraps `read.csv()` to add the file name to any errors:

```{r, error = TRUE, warning = FALSE}
read.csv2 <- function(file, ...) {
  tryCatch(read.csv(file, ...), error = function(c) {
    c$message <- paste0(c$message, " (in ", file, ")")
    stop(c)
  })
}
read.csv("code/dummy.csv")
read.csv2("code/dummy.csv")
```

### Interrupts

Catching interrupts can be useful if you want to take special action when the user tries to abort running code. But be careful, it's easy to create a loop that you can never escape (unless you kill R)! \index{interrupts}

```{r, eval = FALSE}
trapped <- function(times = 3) {
  i <- 1

  message("Try to escape")
  while(i <= times) {
    tryCatch({
      Sys.sleep(1)
    }, interrupt = function(x) {
      message("Try again!")
      i <<- i + 1
    })
  }
  message("You escaped!")
}
trapped()
```

### Finally

`tryCatch()` has one other argument: `finally`. It specifies a block of code (not a function) to run regardless of whether the initial expression succeeds or fails. This can be useful for clean up (e.g., deleting files, closing connections). This is functionally equivalent to using `on.exit()` (and indeed that's how it's implemented) but it can wrap smaller chunks of code than an entire function. \indexc{on.exit()}

## Observing conditions

An alternative to `tryCatch()` is `withCallingHandlers()`. The difference between the two is that the former establishes *exiting* handlers while the latter registers *local* handlers. Here are the main differences between the two kind of handlers: \indexc{withCallingHandlers()}

* The handlers in `withCallingHandlers()` are called in the context of the
  call that generated the condition whereas the handlers in `tryCatch()` are
  called in the context of `tryCatch()`. This is shown here with `sys.calls()`,
  which is the run-time equivalent of `traceback()` --- it lists all calls
  leading to the current function.

    ```{r, eval = FALSE}
    f <- function() g()
    g <- function() h()
    h <- function() stop("!")

    tryCatch(f(), error = function(e) lobstr::cst())
    #> █
    #> └─tryCatch(f(), error = function(e) lobstr::cst())
    #>   └─tryCatchList(expr, classes, parentenv, handlers)
    #>     └─tryCatchOne(expr, names, parentenv, handlers[[1L]])
    #>       └─value[[3L]](cond)
    #>         └─lobstr::cst()
    
    withCallingHandlers(f(), error = function(e) lobstr::cst())
    #> █
    #> ├─withCallingHandlers(f(), error = function(e) lobstr::cst())
    #> ├─f()
    #> │ └─g()
    #> │   └─h()
    #> │     └─stop("!")
    #> └─.handleSimpleError(...)
    #>   └─h(simpleError(msg, call))
    #>     └─lobstr::cst()
    ```

    This also affects the order in which `on.exit()` is called.

* A related difference is that with `tryCatch()`, the flow of execution is
  interrupted when a handler is called, while with `withCallingHandlers()`,
  execution continues normally when the handler returns. This includes the
  signalling function which continues its course after having called the handler
  (e.g., `stop()` will continue stopping the program and `message()` or
  `warning()` will continue signalling a message/warning). This is why it is
  often better to handle a message with `withCallingHandlers()` rather than
  `tryCatch()`, since the latter will stop the program:

    ```{r, message = TRUE}
    message_handler <- function(c) cat("Caught a message!\n")

    tryCatch(message = message_handler, {
      message("Someone there?")
      message("Why, yes!")
    })

    withCallingHandlers(message = message_handler, {
      message("Someone there?")
      message("Why, yes!")
    })
    ```

* The return value of a handler is returned by `tryCatch()`, whereas it is
  ignored with `withCallingHandlers()`:

    ```{r, message = TRUE}
    f <- function() message("!")
    tryCatch(f(), message = function(m) 1)
    withCallingHandlers(f(), message = function(m) 1)
    ```

These subtle differences are rarely useful, except when you're trying to capture exactly what went wrong and pass it on to another function. For most purposes, you should never need to use `withCallingHandlers()`.

### Exercises

* Compare the following two implementations of `message2error()`. What is the
  main advantage of `withCallingHandlers()` in this scenario? (Hint: look
  carefully at the traceback.)

    ```{r}
    message2error <- function(code) {
      withCallingHandlers(code, message = function(e) stop(e))
    }
    message2error <- function(code) {
      tryCatch(code, message = function(e) stop(e))
    }
    ```


## Custom condition classes
\index{errors!custom classes}

One of the challenges of error handling in R is that most functions just call `stop()` with a string. That means if you want to figure out if a particular error occurred, you have to look at the text of the error message. This is error prone, not only because the text of the error might change over time, but also because many error messages are translated, so the message might be completely different to what you expect. 

R has a little known and little used feature to solve this problem. Conditions are S3 classes, so you can define your own classes if you want to distinguish different types of error. Each condition signalling function, `stop()`, `warning()`, and `message()`, can be given either a list of strings, or a custom S3 condition object. Custom condition objects are not used very often, but are very useful because they make it possible for the user to respond to different errors in different ways. For example, "expected" errors (like a model failing to converge for some input datasets) can be silently ignored, while unexpected errors (like no disk space available) can be propagated to the user.

Base R doesn't come with a built-in constructor function for conditions, but rlang provides a family: `cnd()`, `error_cnd()`, `warning_cnd()`, `message_cnd()`

`abort()`, `warn()`, `inform()`.

`cnd_signal()` (doesn't yet exist)

You can then use `tryCatch()` to take different actions for different types of errors. In this example we make a convenient `custom_stop()` function that allows us to signal error conditions with arbitrary classes. In a real application, it would be better to have individual S3 constructor functions that you could document, describing the error classes in more detail.

```{r}
my_log <- function(x) {
  if (!is.numeric(x))
    abort("my_log() needs numeric input", type = "invalid_class")
  if (any(x < 0))
    abort("my_log() needs positive inputs", type = "invalid_value")

  log(x)
}
tryCatch(
  my_log("a"),
  invalid_class = function(c) "class",
  invalid_value = function(c) "value"
)
```

Note that when using `tryCatch()` with multiple handlers and custom classes, the first handler to match any class in the signal's class hierarchy is called, not the best match. For this reason, you need to make sure to put the most specific handlers first:

```{r}
tryCatch(abort("!", type = "my_error"),
  error = function(c) "error",
  my_error = function(c) "my_error"
)
tryCatch(abort("!", type = "my_error"),
  my_error = function(c) "my_error",
  error = function(c) "error"
)
```




## Quiz answers {#conditions-answers}

1. You could use `try()` or `tryCatch()`.

1. Because you can then capture specific types of error with `tryCatch()`,
   rather than relying on the comparison of error strings, which is risky,
   especially when messages are translated.
