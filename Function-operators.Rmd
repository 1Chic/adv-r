# Function operators {#function-operators}

```{r, include = FALSE}
source("common.R")
```

## Introduction
\index{function operators}

In this chapter, you'll learn about function operators (FOs). A function operator is a function that takes one (or more) functions as input and returns a function as output. In some ways, function operators are similar to functionals: there's nothing you can't do without them, but they can make your code more readable and expressive, and they can help you write code faster. The main difference is that functionals extract common patterns of loop use, where function operators extract common patterns of anonymous function use. 

The following code shows a simple function operator, `chatty()`. It wraps a function, making a new function that prints out its first argument. It's useful because it gives you a window to see how functionals, like `map_int()`, work.

```{r, eval = TRUE}
chatty <- function(f) {
  force(f)
  
  function(x, ...) {
    res <- f(x, ...)
    cat("Processing ", x, "\n", sep = "")
    res
  }
}
f <- function(x) x ^ 2
s <- c(3, 2, 1)
chatty(f)(1)

purrr::map_dbl(s, chatty(f))
```

Chapter divided into two main sections. First I'll show you a selection of useful existing operators, or function operators that you can easily create. Second, I'll work through two case studies of using FOs to solve a problem instead of other approaches.

### Outline {-}

* [Behavioural FOs](#behavioural-fos) introduces you to FOs that change the
  behaviour of a function like automatically logging usage to disk or ensuring 
  that a function is run only once.

* [Output FOs](#output-fos) shows you how to write FOs that manipulate the
  output of a function. These can do simple things like capturing errors, or
  fundamentally change what the function does.

* [Input FOs](#input-fos) describes how to modify the inputs to a function using
  a FO like `Vectorize()` or `partial()`.

* [Combining FOs](#combining-fos) shows the power of FOs that combine multiple
  functions with function composition and logical operations.

### Prerequisites {-}

Function operators are a type of function factory, so make sure you're familiar with Sections ...

```{r setup}
library(purrr)
```

<!--
### In other languages

Function operators are used extensively in FP languages like Haskell, and commonly in Lisp, Scheme and Clojure. They are also an important part of modern JavaScript programming, like in the [underscore.js](http://underscorejs.org/) library. They are particularly common in CoffeeScript because its syntax for anonymous functions is so concise. In stack-based languages like Forth and Factor, function operators are used almost exclusively because it's rare to refer to variables by name. Python's decorators are just function operators by a [different name](http://stackoverflow.com/questions/739654/). In Java, they are very rare because it's difficult to manipulate functions (although possible if you wrap them up in strategy-type objects). They are also rare in C++ because, while it's possible to create objects that work like functions ("functors") by overloading the `()` operator, modifying these objects with other functions is not a common programming technique. That said, C++ 11 includes partial application (`std::bind`) as part of the standard library.
-->

## Existing FOs

The next step up in complexity is to modify the output of a function. This could be quite simple, or it could fundamentally change the operation of the function by returning something completely different to its usual output. In this section you'll learn about two simple modifications, `Negate()` and `failwith()`, and two fundamental modifications, `capture_it()` and `time_it()`.

### Capturing errors 


(If you haven't seen `tryCatch()` before, it's discussed in more detail in Section \@ref(handling-conditions).)

`failwith()` is very useful in conjunction with functionals: instead of the failure propagating and terminating the higher-level loop, you can complete the iteration and then find out what went wrong. For example, imagine you're fitting a set of generalised linear models (GLMs) to a list of data frames. While GLMs can sometimes fail because of optimisation problems, you'd still want to be able to try to fit all the models, and later look back at those that failed: \index{fitting many models}

```{r, eval = FALSE}
# If any model fails, all models fail to fit:
fit_model <- function(df) {
  glm(y ~ x1 + x2 * x3, data = df)
}
models <- map(datasets, fit_model)
# If a model fails, it will get a NULL value
models <- map(datasets, safely(fit_model))

```

I think this is a great example of the power of combining functionals and function operators: it lets you succinctly express what you need to solve a common data analysis problem.

### Caching computations
\index{memoisation}

An alternative approach is to use memoisation: modify a function to automatically cache its results. 

```{r, cache = TRUE}
slow_function <- function() {
  Sys.sleep(1)
  10
}
system.time(slow_function())
system.time(slow_function())
fast_function <- memoise::memoise(slow_function)
system.time(fast_function())
system.time(fast_function())
```

Memoisation is an example of the classic computer science tradeoff of memory versus speed. A memoised function can run much faster because it stores all of the previous inputs and outputs, using more memory.

A realistic use of memoisation is computing the Fibonacci series. The Fibonacci series is defined recursively: the first two values are 1 and 1, then f(n) = f(n - 1) + f(n - 2). A naive version implemented in R would be very slow because, for example, `fib(10)` computes `fib(9)` and `fib(8)`, and `fib(9)` computes `fib(8)` and `fib(7)`, and so on. As a result, the value for each value in the series gets computed many, many times. Memoising `fib()` makes the implementation much faster because each value is computed only once. \index{Fibonacci series}

```{r, cache = TRUE}
fib <- function(n) {
  if (n < 2) return(1)
  fib(n - 2) + fib(n - 1)
}
system.time(fib(23))
system.time(fib(24))

fib2 <- memoise::memoise(function(n) {
  if (n < 2) return(1)
  fib2(n - 2) + fib2(n - 1)
})
system.time(fib2(23))
system.time(fib2(24))
```

It doesn't make sense to memoise all functions. For example, a memoised random number generator is no longer random:

```{r}
runifm <- memoise::memoise(runif)
runifm(5)
runifm(5)
```

### Vectorising a function

`base::Vectorize()` converts a scalar function to a vector function. It takes a non-vectorised function and vectorises it with respect to the arguments specified in the vectorize.args argument. This doesn’t give you any magical performance improvements, but it’s useful if you want a quick and dirty way of making a vectorised function.

A mildly useful extension to sample() would be to vectorize it with respect to size. Doing so would allow you to generate multiple samples in one call.

```{r}
sample2 <- Vectorize(sample, "size", SIMPLIFY = FALSE)
str(sample2(1:5, c(1, 1, 3)))

str(sample2(1:5, 5:3))
```

In this example we have used `SIMPLIFY = FALSE` to ensure that our newly vectorised function always returns a list. This is usually what you want.

Note that `Vectorise()` is most useful for quick and dirty throw away functions. It's not terribly much better than doing it by hand with purrr functions:

```{r}
sample3 <- function(x, size, replace = FALSE, prob = NULL) {
  map(size, sample, ~ sample(x, .x, replace = replace, prob = prob))
  # pmap(list(size = size), sample, replace = replace, prob = prob))
}
```

### Exercises

## Creating your own FOs
\indexc{delay\_by()}
\indexc{dot\_every()}

### Downloading files

To motivate these behaviours, imagine we want to download a long vector of URLs. That's pretty simple with `map()` and `download_file()`:

```{r, eval = FALSE}
download_file <- function(url, ...) {
  download.file(url, basename(url), ...)
}
map(urls, download_file)
```

(`download_file()` is a simple wrapper around `utils::download.file()` which provides a reasonable default for the file name.)

There are a number of useful behaviours we might want to add to this function:

* If the list was long, we might want to print a `.` every ten URLs 
  so we know that the function is still working. 
  
* If we're downloading files over the internet, we might want to add 
  a small delay between each request to avoid hammering the server.
  
Implementing these behaviours requires a little work, and unfortunately we can no longer use `map()` because we need an external counter:

```{r, eval = FALSE}
i <- 1
for(url in urls) {
  i <- i + 1
  if (i %% 10 == 0) cat(".")
  Sys.sleep(1)
  download_file(url)
}
```

Understanding this code is hard because different concerns (iteration, printing, and downloading) are interleaved. That also makes the components difficult to reuse in a new situation

In the remainder of this section we'll create FOs that encapsulate each behaviour and allow us to write code like this:

```{r, eval = FALSE}
map(urls, download_file %>% delay_by(1) %>% dot_every(10))
```

Implementing `delay_by()` is straightforward, and follows the same basic template that we'll see for the majority of FOs in this chapter: 

```{r}
delay_by <- function(f, delay) {
  force(f)
  force(delay)
  
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}
system.time(runif(100))
system.time(delay_by(runif, 0.1)(100))
```

Because function operator are just a special type of function factory, we need to ensure that all arguments are evaluated, as in Section \@ref(factory-pitfalls).

`dot_every()` is a little bit more complicated because it needs to manage a counter. Fortunately, we saw how to do that in Section \@ref(stateful-funs). 

```{r}
dot_every <- function(f, n) {
  force(f)
  force(n)
  
  i <- 1
  function(...) {
    if (i %% n == 0) cat(".")
    i <<- i + 1
    f(...)
  }
}
x <- lapply(1:100, runif)
x <- lapply(1:100, dot_every(runif, 10))
```

Code gets a little hard to read if when start to chain many function operators together.

```{r, eval = FALSE}
download <- dot_every(delay_by(download_file, 1), 10)
```

Fortunately we can use the pipe:

```{r, eval = FALSE}
download <- download_file %>% 
  delay_by(1) %>% 
  dot_every(10)
```

I've also tried to give the FOs descriptive names: delay by 1 (second), (print a) dot every 10 (invocations). The more clearly the function names used in your code express your intent, the easier it will be for others (including future you) to read and understand the code.

Another thing you might worry about when downloading multiple files is accidentally downloading the same file multiple times. You could avoid this by calling `unique()` on the list of input URLs, or manually managing a data structure that mapped the URL to the result.

Once we understand `memoise()`, it's straightforward to apply to our problem:

```{r, eval = FALSE}
download <- download_file %>% 
  delay_by(1) %>% 
  memoise() %>% 
  dot_every(10)
```

This gives a function that we can easily use with `map()`. However, if something goes wrong with the loop inside `map()`, it can be difficult to tell what's going on. The next section will show how we can use FOs to pull back the curtain and look inside.

### Understanding functionals
\indexc{tee()}

One challenge with functionals is that it can be hard to see what's going on inside of them. It's not easy to pry open their internals like it is with a for loop. Fortunately we can use FOs to peer behind the curtain with `tee()`.  

`tee()`, defined below, has three arguments, all functions: `f`, the function to modify; `on_input`, a function that's called with the inputs to `f`; and `on_output`, a function that's called with the output from `f`.

```{r}
ignore <- function(...) NULL

tee <- function(f, on_input = ignore, on_output = ignore) {
  force(f)
  force(on_input)
  force(on_output)
  
  function(...) {
    on_input(...)
    output <- f(...)
    on_output(output)
    output
  }
}
```

(The function is inspired by the unix shell command `tee`, which is used to split up streams of file operations so that you can both display what's happening and save intermediate results to a file.)

We can use `tee()` to look inside the `uniroot()` functional, and see how it iterates its way to a solution. The following example finds where `x` and `cos(x)` intersect: \indexc{uniroot()}

```{r}
g <- function(x) cos(x) - x
zero <- uniroot(g, c(-5, 5))
show_x <- function(x, ...) cat(sprintf("%+.08f", x), "\n")

# The location where the function is evaluated:
zero <- uniroot(tee(g, on_input = show_x), c(-5, 5))
# The value of the function:
zero <- uniroot(tee(g, on_output = show_x), c(-5, 5))
```

`cat()` allows us to see what's happening as the function runs, but it doesn't give us a way to work with the values after the function as completed. To do that, we could capture the sequence of calls by creating a function, `remember()`, that records every argument called and retrieves them when coerced into a list. The small amount of S3 code needed is explained in [S3](#s3). \indexc{remember()}

```{r}
remember <- function() {
  memory <- list()
  f <- function(...) {
    # This is inefficient!
    memory <<- append(memory, list(...))
    invisible()
  }

  structure(f, class = "remember")
}
as.list.remember <- function(x, ...) {
  environment(x)$memory
}
print.remember <- function(x, ...) {
  cat("Remembering...\n")
  str(as.list(x))
}
```

Now we can draw a picture showing how uniroot zeroes in on the final answer:

```{r, uniroot-explore, small_mar = TRUE, fig.width = 3, fig.height = 2}
locs <- remember()
vals <- remember()
zero <- uniroot(tee(g, locs, vals), c(-5, 5))
x <- unlist(as.list(locs))
error <- unlist(as.list(vals))
plot(x, type = "b"); abline(h = 0.739, col = "grey50")
plot(error, type = "b"); abline(h = 0, col = "grey50")
```

### A family of function operators
\index{predicate functions}
\index{Boolean algebra}
\indexc{Negate()} 

`Negate()` takes a function that returns a logical vector (a predicate function), and returns the negation of that function. This can be a useful shortcut when a function returns the opposite of what you need. The essence of `Negate()` is very simple:

```{r}
Negate <- function(f) {
  force(f)
  function(...) !f(...)
}
(Negate(is.null))(NULL)
```

`purrr::possibly()` turns a function that throws an error into a function that returns a default value when there's an error. Again, the essence of `failwith()` is simple; it's just a wrapper around `try()`, the function that captures errors and allows execution to continue. \indexc{try()}


When I use `Filter()` and other functionals that work with logical predicates, I often find myself using anonymous functions to combine multiple conditions: 

```{r, eval = FALSE}
keep(iris, ~ is.character(.x) || is.factor(.x))
```

As an alternative, we could define function operators that combine logical predicates:

```{r}
and <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) && f2(...)
  }
}

or <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) || f2(...)
  }
}

not <- function(f) {
  force(f)
  function(...) {
    !f(...)
  }
}
```

This would allow us to write:

```{r, eval = FALSE}
keep(iris, or(is.character, is.factor))
keep(iris, not(is.numeric))
```

And we now have a boolean algebra on functions, not on the results of functions.

### Exercises

1.  The `evaluate` package makes it easy to capture all the outputs (results, 
    text, messages, warnings, errors, and plots) from an expression. Create a 
    function like `capture_it()` that also captures the warnings and errors 
    generated by a function.

1.  Create a FO that tracks files created or deleted in the working directory 
    (Hint: use `dir()` and `setdiff()`.) What other global effects of 
    functions might you want to track?

1.  Write a FO that logs a time stamp and message to a file every time a 
    function is run.

1.  What does the following function do? What would be a good name for it?

    ```{r}
    f <- function(g) {
      force(g)
      result <- NULL
      function(...) {
        if (is.null(result)) {
          result <<- g(...)
        }
        result
      }
    }
    runif2 <- f(runif)
    runif2(5)
    runif2(10)
    ```

1.  Modify `delay_by()` so that instead of delaying by a fixed amount of time, 
    it ensures that a certain amount of time has elapsed since the function 
    was last called. That is, if you called 
    `g <- delay_by(1, f); g(); Sys.sleep(2); g()` there shouldn't be an 
    extra delay.

1.  Write `wait_until()` which delays execution until a specific time.

1.  There are three places we could have added a memoise call: why did we 
    choose the one we did?

    ```{r, eval = FALSE}
    download <- memoise(dot_every(10, delay_by(1, download_file)))
    download <- dot_every(10, memoise(delay_by(1, download_file)))
    download <- dot_every(10, delay_by(1, memoise(download_file)))
    ```

1.  Make infix versions of the functions so you can write 
    `keep(iris, is.character %or% is.factor))`

1.  Extend `and()` and `or()` to deal with any number of input functions. Can 
    you do it with `reduce()`? Can you keep them lazy (e.g., for `and()`, the 
    function returns once it sees the first `FALSE`)?

1.  Implement the `xor()` binary operator. Implement it using the existing 
    `xor()` function. Implement it as a combination of `and()` and `or()`. What 
    are the advantages and disadvantages of each approach? Also think about 
    what you'll call the resulting function to avoid a clash with the existing
    `xor()` function, and how you might change the names of `and()`, `not()`, 
    and `or()` to keep them consistent.

1.  Above, we implemented boolean algebra for functions that return a logical 
    function. Implement elementary algebra (`plus()`, `minus()`, `multiply()`, 
    `divide()`, `exponentiate()`, `log()`) for functions that return numeric 
    vectors.
