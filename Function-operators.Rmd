# Function operators {#function-operators}

```{r, include = FALSE}
source("common.R")
```

## Introduction
\index{function operators}

In this chapter, you'll learn about function operators (FOs). A function operator is a function that takes one (or more) functions as input and returns a function as output. In some ways, function operators are similar to functionals: there's nothing you can't do without them, but they can make your code more readable and expressive, and they can help you write code faster. The main difference is that functionals extract common patterns of loop use, where function operators extract common patterns of anonymous function use. 

The following code shows a simple function operator, `chatty()`. It wraps a function, making a new function that prints out its first argument. You might create a function like this because it gives you a window to see how functionals, like `map_int()`, work.

```{r, eval = TRUE}
chatty <- function(f) {
  force(f)
  
  function(x, ...) {
    res <- f(x, ...)
    cat("Processing ", x, "\n", sep = "")
    res
  }
}
f <- function(x) x ^ 2
s <- c(3, 2, 1)
chatty(f)(1)

purrr::map_dbl(s, chatty(f))
```

The chapter is divided into two main sections. First, I'll show you a three useful existing operators FO, and show you how use them to solve real problems. Second, I'll work through two case studies of using FOs to solve a problem instead of other approaches.

### Outline {-}

### Prerequisites {-}

Function operators are a type of function factory, so make sure you're familiar with Section \@ref(function-fundamentals) before you go on. We'll use a couple of functionals from purrr that you learned about in Chapter \@ref(functionals), as well as some function operators that you'll learn about below. We'll use the memoise package for a useful FO.

```{r setup}
library(purrr)
library(memoise)
```

<!--
### In other languages

Function operators are used extensively in FP languages like Haskell, and commonly in Lisp, Scheme and Clojure. They are also an important part of modern JavaScript programming, like in the [underscore.js](http://underscorejs.org/) library. They are particularly common in CoffeeScript because its syntax for anonymous functions is so concise. In stack-based languages like Forth and Factor, function operators are used almost exclusively because it's rare to refer to variables by name. Python's decorators are just function operators by a [different name](http://stackoverflow.com/questions/739654/). In Java, they are very rare because it's difficult to manipulate functions (although possible if you wrap them up in strategy-type objects). They are also rare in C++ because, while it's possible to create objects that work like functions ("functors") by overloading the `()` operator, modifying these objects with other functions is not a common programming technique. That said, C++ 11 includes partial application (`std::bind`) as part of the standard library.
-->

## Existing FOs

There are two extremely useful function operators that will both help you solve common recurring problems, and give you a sense for what FOs can do: `purrr::safely()` and `memoise::memoise()`.

### Capturing errors with `purrr::safely()` {#safely}
\indexc{safely()}

One advantage of a for-loops is that if one of the iterations fails in a for-loop you can still access all the previous results:

```{r, error = TRUE}
x <- list(
  c(0.512, 0.165, 0.717),
  c(0.064, 0.781, 0.427),
  c(0.890, 0.785, 0.495),
  "oops"
)

out <- rep(NA_real_, length(x))
for (i in seq_along(x)) {
  out[[i]] <- sum(x[[i]])
}
out
```

If you run the same code with a functional, you get no output and it can be hard to figure out where the problem lies:

```{r, error = TRUE}
map_dbl(x, sum)
```

`purrr::safely()` provides a tool to help with this problem. `safely()` is a function operator that transforms a function to turn errors into data. (You can learn the basic idea that makes it work in Section \@ref(try-success-failure)). Let's start by taking a look at it outside of `map_dbl()`:

```{r}
safe_sum <- safely(sum)
str(safe_sum(x[[1]]))
str(safe_sum(x[[4]]))
```

A function transformed by `safely()` always returns a list with two elements, `result` and `error`. If the function runs successfully, `error` is `NULL` and `result` contains the result; if the function fails, `result` is `NULL` and `error` contains the error.

```{r}
out <- map(x, safely(sum))
str(out)
```

The output is in a slightly inconveient form, since we have four lists each containing a list containing the result and the error. We can make it more convenient by using `purrr::transpose()` to turn it "inside-out" so that we get a list of result and a list of errors:

```{r}
out <- transpose(map(x, safely(sum)))
str(out)
```

Now we can easily find the results the worked, or the inputs that failed:

```{r}
ok <- map_lgl(out$error, is.null)
ok

x[!ok]

out$result[ok]
```

You can use this same technique in many different situtations. For example, imagine you're fitting a set of generalised linear models (GLMs) to a list of data frames. While GLMs can sometimes fail because of optimisation problems, you'd still want to be able to try to fit all the models, and later look back at those that failed: \index{fitting many models}

```{r, eval = FALSE}
fit_model <- function(df) {
  glm(y ~ x1 + x2 * x3, data = df)
}

models <- transpose(map(datasets, safely(fit_model)))
ok <- map_lgl(models$error, is.null)

# which data failed to converge?
datasets[!ok]

# which models were successful?
models[ok]
```

I think this is a great example of the power of combining functionals and function operators: it lets you succinctly express what you need to solve a common data analysis problem. 

purrr comes with three other function operators in a similar vein:

* `possibly()`: returns a default value when there's an error.

* `quietly()`: turns output, messages, and warning side-effects in to
  `output`, `message`, and `warning` components of the output.

* `auto_browser()`: automatically executes `browser()` inside the 
  function when there's an error.

See their documentation for more details.

### Caching computations with `memoise::memoise()` {#memoise}
\index{memoisation}
\indexc{memoise()}
\index{Fibonacci series}

An extremely handy FO is `memoise::memoise()`. It __memoises__ a function, meaning that the function will remember previous inputs and return a cache results. Memoisation is an example of the classic computer science tradeoff of memory versus speed. A memoised function can run much faster because it stores all of the previous inputs and outputs, using more memory.

Let's explore this idea with a toy function that simulates an expensive operation:

```{r, cache = TRUE}
slow_function <- function(x) {
  Sys.sleep(1)
  x * 10 * runif(1)
}
system.time(print(slow_function(1)))

system.time(print(slow_function(1)))
```

When we memoise this function, it's slow when we call it with new arguments. But when we call it with arguments that it's seen before it's instanteous: it retrieves the previous value of the computation.

```{r, cache = TRUE}
fast_function <- memoise::memoise(slow_function)
system.time(print(fast_function(1)))

system.time(print(fast_function(1)))
```

A relatively realistic use of memoisation is computing the Fibonacci series. The Fibonacci series is defined recursively: the first two values are defined by convention, $f(0) = 0$, $f(n) = 1$, and then $f(n) = f(n - 1) + f(n - 2)$ (for any positive integer). A naive version is slow because, for example, `fib(10)` computes `fib(9)` and `fib(8)`, and `fib(9)` computes `fib(8)` and `fib(7)`, and so on. 

```{r}
fib <- function(n) {
  if (n < 2) return(1)
  fib(n - 2) + fib(n - 1)
}
system.time(fib(23))
system.time(fib(24))
```

Memoising `fib()` makes the implementation much faster because each value is computed only once:

```{r}
fib2 <- memoise::memoise(function(n) {
  if (n < 2) return(1)
  fib2(n - 2) + fib2(n - 1)
})
system.time(fib2(23))
```

And future calls can rely on previous computations:

```{r}
system.time(fib2(24))
```

This is an example of __dynamic programming__, where a complex problem can be broken down into many overlapping subproblems, and remembering the results of a subproblem considerably improves performance. 

Think carefully before memoising a function. If the function is not __pure__, i.e. the output does not depend only on the input, you will get misleading and confusing results. I created a subtle bug in devtools because I memoised the results of `available.package()`, which is rather slow because it has to download a large file from CRAN. The available packages don't change that frequently, but if you have an R process that's been running for a few days, the changes can become important, and because the problem only arose in long-running R process, the bug was very painful to find.

### Exercises

1.  Base R provides a function operator in the form of `Vectorize()`. 
    What does it do? When might you use it?

## Creating your own FOs
\indexc{delay\_by()}
\indexc{dot\_every()}

### Downloading files

To motivate these behaviours, imagine we want to download a long vector of URLs. That's pretty simple with `map()` and `download_file()`:

```{r, eval = FALSE}
download_file <- function(url, ...) {
  download.file(url, basename(url), ...)
}
map(urls, download_file)
```

(`download_file()` is a simple wrapper around `utils::download.file()` which provides a reasonable default for the file name.)

There are a number of useful behaviours we might want to add to this function:

* If the list was long, we might want to print a `.` every ten URLs 
  so we know that the function is still working. 
  
* If we're downloading files over the internet, we might want to add 
  a small delay between each request to avoid hammering the server.
  
Implementing these behaviours requires a little work, and unfortunately we can no longer use `map()` because we need an external counter:

```{r, eval = FALSE}
i <- 1
for(url in urls) {
  i <- i + 1
  if (i %% 10 == 0) cat(".")
  Sys.sleep(1)
  download_file(url)
}
```

Understanding this code is hard because different concerns (iteration, printing, and downloading) are interleaved. That also makes the components difficult to reuse in a new situation

In the remainder of this section we'll create FOs that encapsulate each behaviour and allow us to write code like this:

```{r, eval = FALSE}
map(urls, download_file %>% delay_by(1) %>% dot_every(10))
```

Implementing `delay_by()` is straightforward, and follows the same basic template that we'll see for the majority of FOs in this chapter: 

```{r}
delay_by <- function(f, delay) {
  force(f)
  force(delay)
  
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}
system.time(runif(100))
system.time(delay_by(runif, 0.1)(100))
```

Because function operator are just a special type of function factory, we need to ensure that all arguments are evaluated, as in Section \@ref(factory-pitfalls).

`dot_every()` is a little bit more complicated because it needs to manage a counter. Fortunately, we saw how to do that in Section \@ref(stateful-funs). 

```{r}
dot_every <- function(f, n) {
  force(f)
  force(n)
  
  i <- 1
  function(...) {
    if (i %% n == 0) cat(".")
    i <<- i + 1
    f(...)
  }
}
x <- lapply(1:100, runif)
x <- lapply(1:100, dot_every(runif, 10))
```

Code gets a little hard to read if when start to chain many function operators together.

```{r, eval = FALSE}
download <- dot_every(delay_by(download_file, 1), 10)
```

Fortunately we can use the pipe:

```{r, eval = FALSE}
download <- download_file %>% 
  delay_by(1) %>% 
  dot_every(10)
```

I've also tried to give the FOs descriptive names: delay by 1 (second), (print a) dot every 10 (invocations). The more clearly the function names used in your code express your intent, the easier it will be for others (including future you) to read and understand the code.

Another thing you might worry about when downloading multiple files is accidentally downloading the same file multiple times. You could avoid this by calling `unique()` on the list of input URLs, or manually managing a data structure that mapped the URL to the result.

Once we understand `memoise()`, it's straightforward to apply to our problem:

```{r, eval = FALSE}
download <- download_file %>% 
  delay_by(1) %>% 
  memoise() %>% 
  dot_every(10)
```

This gives a function that we can easily use with `map()`. However, if something goes wrong with the loop inside `map()`, it can be difficult to tell what's going on. The next section will show how we can use FOs to pull back the curtain and look inside.

### Understanding functionals
\indexc{tee()}

One challenge with functionals is that it can be hard to see what's going on inside of them. It's not easy to pry open their internals like it is with a for loop. Fortunately we can use FOs to peer behind the curtain with `tee()`.  

`tee()`, defined below, has three arguments, all functions: `f`, the function to modify; `on_input`, a function that's called with the inputs to `f`; and `on_output`, a function that's called with the output from `f`.

```{r}
ignore <- function(...) NULL

tee <- function(f, on_input = ignore, on_output = ignore) {
  force(f)
  force(on_input)
  force(on_output)
  
  function(...) {
    on_input(...)
    output <- f(...)
    on_output(output)
    output
  }
}
```

(The function is inspired by the unix shell command `tee`, which is used to split up streams of file operations so that you can both display what's happening and save intermediate results to a file.)

We can use `tee()` to look inside the `uniroot()` functional, and see how it iterates its way to a solution. The following example finds where `x` and `cos(x)` intersect: \indexc{uniroot()}

```{r}
g <- function(x) cos(x) - x
zero <- uniroot(g, c(-5, 5))
show_x <- function(x, ...) cat(sprintf("%+.08f", x), "\n")

# The location where the function is evaluated:
zero <- uniroot(tee(g, on_input = show_x), c(-5, 5))
# The value of the function:
zero <- uniroot(tee(g, on_output = show_x), c(-5, 5))
```

`cat()` allows us to see what's happening as the function runs, but it doesn't give us a way to work with the values after the function as completed. To do that, we could capture the sequence of calls by creating a function, `remember()`, that records every argument called and retrieves them when coerced into a list. The small amount of S3 code needed is explained in [S3](#s3). \indexc{remember()}

```{r}
remember <- function() {
  memory <- list()
  f <- function(...) {
    # This is inefficient!
    memory <<- append(memory, list(...))
    invisible()
  }

  structure(f, class = "remember")
}
as.list.remember <- function(x, ...) {
  environment(x)$memory
}
print.remember <- function(x, ...) {
  cat("Remembering...\n")
  str(as.list(x))
}
```

Now we can draw a picture showing how uniroot zeroes in on the final answer:

```{r, uniroot-explore, small_mar = TRUE, fig.width = 3, fig.height = 2}
locs <- remember()
vals <- remember()
zero <- uniroot(tee(g, locs, vals), c(-5, 5))
x <- unlist(as.list(locs))
error <- unlist(as.list(vals))
plot(x, type = "b"); abline(h = 0.739, col = "grey50")
plot(error, type = "b"); abline(h = 0, col = "grey50")
```


### Exercises

1.  The `evaluate` package makes it easy to capture all the outputs (results, 
    text, messages, warnings, errors, and plots) from an expression. Create a 
    function like `capture_it()` that also captures the warnings and errors 
    generated by a function.

1.  Create a FO that tracks files created or deleted in the working directory 
    (Hint: use `dir()` and `setdiff()`.) What other global effects of 
    functions might you want to track?

1.  Write a FO that logs a time stamp and message to a file every time a 
    function is run.

1.  What does the following function do? What would be a good name for it?

    ```{r}
    f <- function(g) {
      force(g)
      result <- NULL
      function(...) {
        if (is.null(result)) {
          result <<- g(...)
        }
        result
      }
    }
    runif2 <- f(runif)
    runif2(5)
    runif2(10)
    ```

1.  Modify `delay_by()` so that instead of delaying by a fixed amount of time, 
    it ensures that a certain amount of time has elapsed since the function 
    was last called. That is, if you called 
    `g <- delay_by(1, f); g(); Sys.sleep(2); g()` there shouldn't be an 
    extra delay.

1.  Write `wait_until()` which delays execution until a specific time.

1.  There are three places we could have added a memoise call: why did we 
    choose the one we did?

    ```{r, eval = FALSE}
    download <- memoise(dot_every(10, delay_by(1, download_file)))
    download <- dot_every(10, memoise(delay_by(1, download_file)))
    download <- dot_every(10, delay_by(1, memoise(download_file)))
    ```

1.  Make infix versions of the functions so you can write 
    `keep(iris, is.character %or% is.factor))`

1.  Extend `and()` and `or()` to deal with any number of input functions. Can 
    you do it with `reduce()`? Can you keep them lazy (e.g., for `and()`, the 
    function returns once it sees the first `FALSE`)?

1.  Implement the `xor()` binary operator. Implement it using the existing 
    `xor()` function. Implement it as a combination of `and()` and `or()`. What 
    are the advantages and disadvantages of each approach? Also think about 
    what you'll call the resulting function to avoid a clash with the existing
    `xor()` function, and how you might change the names of `and()`, `not()`, 
    and `or()` to keep them consistent.

1.  Above, we implemented boolean algebra for functions that return a logical 
    function. Implement elementary algebra (`plus()`, `minus()`, `multiply()`, 
    `divide()`, `exponentiate()`, `log()`) for functions that return numeric 
    vectors.
